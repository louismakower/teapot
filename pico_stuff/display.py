from machine import Pin, SPI
import time

TEA_BITMAP = bytearray([
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x60, 0x07, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x70, 0x0E, 0x00, 0xE0, 0x00, 0x00, 
    0x00, 0x00, 0x30, 0x0C, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 0x00, 0x70, 0x00, 0x00, 
    0x00, 0x00, 0x30, 0x18, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x70, 0x18, 0x00, 0x60, 0x00, 0x00, 
    0x00, 0x00, 0x60, 0x18, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x0C, 0x00, 0xC0, 0x00, 0x00, 
    0x00, 0x00, 0xC0, 0x0E, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x04, 0x01, 0x80, 0x00, 0x00, 
    0x00, 0x00, 0xC0, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xC0, 0x00, 0x00, 
    0x00, 0x00, 0x60, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 
    0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x18, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1F, 0xFF, 
    0x03, 0x80, 0x3F, 0xC0, 0x00, 0x00, 0x1F, 0xFF, 0x01, 0x80, 0x3F, 0xE0, 0x00, 0x00, 0x18, 0x03, 
    0x01, 0x80, 0x30, 0xE0, 0x00, 0x00, 0x18, 0x07, 0x01, 0x80, 0x30, 0xE0, 0x00, 0x00, 0x18, 0x06, 
    0x01, 0x80, 0x30, 0xE0, 0x00, 0x00, 0x38, 0x06, 0x01, 0x80, 0x30, 0xE0, 0x00, 0x00, 0x30, 0x0C, 
    0x01, 0xC0, 0x30, 0xE0, 0x00, 0x00, 0x30, 0x1C, 0x00, 0xC0, 0x30, 0xE0, 0x00, 0x00, 0x30, 0x38, 
    0x00, 0xC0, 0x3F, 0xE0, 0x00, 0x00, 0x70, 0x70, 0x00, 0xE0, 0x3F, 0xC0, 0x00, 0x00, 0x61, 0xE0, 
    0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
    0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 
    0x00, 0x18, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 
    0x00, 0x0E, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 
    0x00, 0x03, 0x80, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x38, 0x00, 0x00, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 
    0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xC0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x80, 
    0x07, 0xE0, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x01, 0xFE, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 
    0x00, 0x3F, 0xF8, 0x00, 0x03, 0xFF, 0x80, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 
    0x00, 0x00, 0x0F, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
])
COFFEE_BITMAP = bytearray([
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x07, 0xF8, 0x7F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF8, 0x0F, 0xC0, 0x00, 0x00, 0x00, 0x00, 
    0x1F, 0xF8, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x78, 0x01, 0xF0, 0x00, 0x00, 0x00, 0x00, 
    0x3E, 0x78, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x78, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 
    0x78, 0x78, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x78, 0x78, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 
    0x78, 0x78, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x70, 0x78, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 
    0xF0, 0x3C, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0xF0, 0x3C, 0x00, 0x07, 0x80, 0x0F, 0xF0, 0x00, 
    0xF0, 0x1E, 0x00, 0x03, 0xC0, 0xFF, 0xFE, 0x00, 0xF0, 0x1F, 0x00, 0x03, 0xC7, 0xFF, 0xFF, 0x80, 
    0xF0, 0x0F, 0x00, 0x03, 0xDF, 0xFF, 0xFF, 0xE0, 0xF0, 0x07, 0xC0, 0x01, 0xFF, 0xE0, 0x07, 0xF0, 
    0xF0, 0x07, 0xE0, 0x01, 0xFF, 0x00, 0x01, 0xF8, 0xF0, 0x03, 0xF0, 0x01, 0xFC, 0x00, 0x00, 0x78, 
    0xF0, 0x00, 0xFC, 0x03, 0xF0, 0x00, 0x03, 0xFC, 0x70, 0x00, 0x7C, 0x07, 0xC0, 0x00, 0x1F, 0xFE, 
    0x78, 0x00, 0x3E, 0x0F, 0x80, 0x00, 0x7F, 0xFE, 0x78, 0x00, 0x1F, 0x1F, 0x00, 0x01, 0xFF, 0xFE, 
    0x78, 0x00, 0x0F, 0x3E, 0x00, 0x03, 0xF8, 0x0F, 0x3C, 0x00, 0x0F, 0xBC, 0x00, 0x07, 0xE0, 0x0F, 
    0x3C, 0x00, 0x07, 0xF8, 0x00, 0x0F, 0x80, 0x0F, 0x1E, 0x00, 0x03, 0xF8, 0x00, 0x1F, 0x00, 0x0F, 
    0x1E, 0x00, 0x03, 0xF0, 0x00, 0x1E, 0x00, 0x0F, 0x1F, 0x00, 0x03, 0xF0, 0x00, 0x3C, 0x00, 0x0F, 
    0x0F, 0x80, 0x03, 0xE0, 0x00, 0x3C, 0x00, 0x0F, 0x07, 0x80, 0x03, 0xE0, 0x00, 0x78, 0x00, 0x1E, 
    0x07, 0xC0, 0x03, 0xC0, 0x00, 0xF8, 0x00, 0x1E, 0x03, 0xE0, 0x03, 0xC0, 0x00, 0xF0, 0x00, 0x1E, 
    0x01, 0xF8, 0x03, 0xC0, 0x01, 0xF0, 0x00, 0x3C, 0x00, 0xFC, 0x03, 0xC0, 0x03, 0xE0, 0x00, 0x3C, 
    0x00, 0x7F, 0x03, 0xC0, 0x07, 0xC0, 0x00, 0x78, 0x00, 0x3F, 0xF7, 0xC0, 0x1F, 0xC0, 0x00, 0xF8, 
    0x00, 0x0F, 0xFF, 0xE0, 0xFF, 0x00, 0x01, 0xF0, 0x00, 0x07, 0xFF, 0xFF, 0xFE, 0x00, 0x03, 0xE0, 
    0x00, 0x00, 0xFF, 0xFF, 0xF8, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x1F, 0x80, 
    0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0xFE, 0x00, 
    0x00, 0x00, 0x00, 0x3F, 0x00, 0x03, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF0, 0x3F, 0xF0, 0x00, 
    0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
])
UNDO_BITMAP = bytearray([
    0x00, 0x00, 0x00, 0x00, 0x7F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xF8, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x80, 0x00, 
    0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 
    0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 
    0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 
    0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x7F, 0xFF, 0xE0, 0xFF, 0xFF, 0xC0, 
    0x00, 0x00, 0xFF, 0xFE, 0x00, 0x1F, 0xFF, 0xC0, 0x00, 0x01, 0xFF, 0xF8, 0x00, 0x07, 0xFF, 0xE0, 
    0x00, 0x01, 0xFF, 0xF0, 0x00, 0x03, 0xFF, 0xF0, 0x00, 0x03, 0xFF, 0xE0, 0x00, 0x00, 0xFF, 0xF0, 
    0x00, 0x03, 0xFF, 0xC0, 0x00, 0x00, 0x7F, 0xF8, 0x00, 0x07, 0xFF, 0x80, 0x00, 0x00, 0x7F, 0xF8, 
    0x00, 0x07, 0xFF, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x00, 0x0F, 0xFE, 0x00, 0x00, 0x00, 0x1F, 0xFC, 
    0x00, 0x0F, 0xFE, 0x00, 0x00, 0x00, 0x0F, 0xFC, 0x00, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x0F, 0xFE, 
    0x00, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x1F, 0xF8, 0x00, 0x00, 0x00, 0x07, 0xFE, 
    0x00, 0x1F, 0xF8, 0x00, 0x00, 0x00, 0x07, 0xFE, 0x1C, 0x1F, 0xF8, 0x70, 0x00, 0x00, 0x03, 0xFE, 
    0x3F, 0x1F, 0xF1, 0xF8, 0x00, 0x00, 0x03, 0xFF, 0x7F, 0x9F, 0xF3, 0xFC, 0x00, 0x00, 0x03, 0xFF, 
    0xFF, 0xFF, 0xF7, 0xFC, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x03, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x01, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x01, 0xFF, 0x7F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x03, 0xFF, 
    0x7F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x03, 0xFF, 0x3F, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x03, 0xFF, 
    0x1F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x03, 0xFF, 0x0F, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x03, 0xFF, 
    0x0F, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x03, 0xFE, 0x07, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x07, 0xFE, 
    0x03, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x07, 0xFE, 0x01, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07, 0xFE, 
    0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x0F, 0xFE, 0x00, 0x7F, 0xFC, 0x00, 0x00, 0x00, 0x0F, 0xFC, 
    0x00, 0x3F, 0xF8, 0x00, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x3F, 0xF8, 
    0x00, 0x1F, 0xF0, 0x00, 0x00, 0x00, 0x7F, 0xF8, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xF8, 
    0x00, 0x07, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xF0, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xC0, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0x80, 
    0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFE, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xF8, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE0, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x80, 0x00, 0x00, 
])
# Colors (RGB565 format)
BLACK = 0x0000
WHITE = 0xFFFF
RED = 0xF800
GREEN = 0x07E0
BLUE = 0x001F
YELLOW = 0xFFE0
MAGENTA = 0xF81F
CYAN = 0x07FF

class ManualGC9A01:
    def __init__(self, spi, dc, cs, reset, backlight):
        self.spi = spi
        self.dc = dc
        self.cs = cs
        self.reset = reset
        self.backlight = backlight
        self.width = 240
        self.height = 240
        
        self.backlight.on()
        self.reset_display()
        self.init_display()
        
        # Basic 8x8 font (simplified for demonstration)
        self.font_8x8 = {
            'A': [0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
            'B': [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00],
            'C': [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00],
            'D': [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00],
            'E': [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00],
            'F': [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00],
            'G': [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00],
            'H': [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
            'I': [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
            'J': [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00],
            'K': [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00],
            'L': [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00],
            'M': [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00],
            'N': [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00],
            'O': [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
            'P': [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00],
            'Q': [0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00],
            'R': [0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00],
            'S': [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00],
            'T': [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
            'U': [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
            'V': [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
            'W': [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00],
            'X': [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00],
            'Y': [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00],
            'Z': [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00],
            '0': [0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00],
            '1': [0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00],
            '2': [0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00],
            '3': [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00],
            '4': [0x06, 0x0E, 0x1E, 0x66, 0x7F, 0x06, 0x06, 0x00],
            '5': [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00],
            '6': [0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00],
            '7': [0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00],
            '8': [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00],
            '9': [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00],
            ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            '!': [0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00],
            '?': [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00],
            '.': [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
            ',': [0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00],
            ':': [0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00],
            '-': [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
            '+': [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00],
            "'": [0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00],
        }
    
    def reset_display(self):
        self.reset.off()
        time.sleep(0.01)
        self.reset.on()
        time.sleep(0.1)
    
    def write_cmd(self, cmd):
        self.cs.off()
        self.dc.off()
        self.spi.write(bytearray([cmd]))
        self.cs.on()
    
    def write_data(self, data):
        self.cs.off()
        self.dc.on()
        if isinstance(data, int):
            self.spi.write(bytearray([data]))
        else:
            self.spi.write(data)
        self.cs.on()
    
    def init_display(self):
        # GC9A01 initialization sequence (same as before)
        self.write_cmd(0xEF)
        self.write_cmd(0xEB)
        self.write_data(0x14)
        
        self.write_cmd(0xFE)
        self.write_cmd(0xEF)
        
        self.write_cmd(0xEB)
        self.write_data(0x14)
        
        self.write_cmd(0x84)
        self.write_data(0x40)
        
        self.write_cmd(0x85)
        self.write_data(0xFF)
        
        self.write_cmd(0x86)
        self.write_data(0xFF)
        
        self.write_cmd(0x87)
        self.write_data(0xFF)
        
        self.write_cmd(0x88)
        self.write_data(0x0A)
        
        self.write_cmd(0x89)
        self.write_data(0x21)
        
        self.write_cmd(0x8A)
        self.write_data(0x00)
        
        self.write_cmd(0x8B)
        self.write_data(0x80)
        
        self.write_cmd(0x8C)
        self.write_data(0x01)
        
        self.write_cmd(0x8D)
        self.write_data(0x01)
        
        self.write_cmd(0x8E)
        self.write_data(0xFF)
        
        self.write_cmd(0x8F)
        self.write_data(0xFF)
        
        self.write_cmd(0xB6)
        self.write_data(0x00)
        self.write_data(0x20)
        
        self.write_cmd(0x36)
        self.write_data(0x08)
        
        self.write_cmd(0x3A)
        self.write_data(0x05)
        
        self.write_cmd(0x90)
        self.write_data(0x08)
        self.write_data(0x08)
        self.write_data(0x08)
        self.write_data(0x08)
        
        self.write_cmd(0xBD)
        self.write_data(0x06)
        
        self.write_cmd(0xBC)
        self.write_data(0x00)
        
        self.write_cmd(0xFF)
        self.write_data(0x60)
        self.write_data(0x01)
        self.write_data(0x04)
        
        self.write_cmd(0xC3)
        self.write_data(0x13)
        
        self.write_cmd(0xC4)
        self.write_data(0x13)
        
        self.write_cmd(0xC9)
        self.write_data(0x22)
        
        self.write_cmd(0xBE)
        self.write_data(0x11)
        
        self.write_cmd(0xE1)
        self.write_data(0x10)
        self.write_data(0x0E)
        
        self.write_cmd(0xDF)
        self.write_data(0x21)
        self.write_data(0x0C)
        self.write_data(0x02)
        
        self.write_cmd(0xF0)
        self.write_data(0x45)
        self.write_data(0x09)
        self.write_data(0x08)
        self.write_data(0x08)
        self.write_data(0x26)
        self.write_data(0x2A)
        
        self.write_cmd(0xF1)
        self.write_data(0x43)
        self.write_data(0x70)
        self.write_data(0x72)
        self.write_data(0x36)
        self.write_data(0x37)
        self.write_data(0x6F)
        
        self.write_cmd(0xF2)
        self.write_data(0x45)
        self.write_data(0x09)
        self.write_data(0x08)
        self.write_data(0x08)
        self.write_data(0x26)
        self.write_data(0x2A)
        
        self.write_cmd(0xF3)
        self.write_data(0x43)
        self.write_data(0x70)
        self.write_data(0x72)
        self.write_data(0x36)
        self.write_data(0x37)
        self.write_data(0x6F)
        
        self.write_cmd(0xED)
        self.write_data(0x1B)
        self.write_data(0x0B)
        
        self.write_cmd(0xAE)
        self.write_data(0x77)
        
        self.write_cmd(0xCD)
        self.write_data(0x63)
        
        self.write_cmd(0x70)
        self.write_data(0x07)
        self.write_data(0x07)
        self.write_data(0x04)
        self.write_data(0x0E)
        self.write_data(0x0F)
        self.write_data(0x09)
        self.write_data(0x07)
        self.write_data(0x08)
        self.write_data(0x03)
        
        self.write_cmd(0xE8)
        self.write_data(0x34)
        
        self.write_cmd(0x62)
        self.write_data(0x18)
        self.write_data(0x0D)
        self.write_data(0x71)
        self.write_data(0xED)
        self.write_data(0x70)
        self.write_data(0x70)
        self.write_data(0x18)
        self.write_data(0x0F)
        self.write_data(0x71)
        self.write_data(0xEF)
        self.write_data(0x70)
        self.write_data(0x70)
        
        self.write_cmd(0x63)
        self.write_data(0x18)
        self.write_data(0x11)
        self.write_data(0x71)
        self.write_data(0xF1)
        self.write_data(0x70)
        self.write_data(0x70)
        self.write_data(0x18)
        self.write_data(0x13)
        self.write_data(0x71)
        self.write_data(0xF3)
        self.write_data(0x70)
        self.write_data(0x70)
        
        self.write_cmd(0x64)
        self.write_data(0x28)
        self.write_data(0x29)
        self.write_data(0xF1)
        self.write_data(0x01)
        self.write_data(0xF1)
        self.write_data(0x00)
        self.write_data(0x07)
        
        self.write_cmd(0x66)
        self.write_data(0x3C)
        self.write_data(0x00)
        self.write_data(0xCD)
        self.write_data(0x67)
        self.write_data(0x45)
        self.write_data(0x45)
        self.write_data(0x10)
        self.write_data(0x00)
        self.write_data(0x00)
        self.write_data(0x00)
        
        self.write_cmd(0x67)
        self.write_data(0x00)
        self.write_data(0x3C)
        self.write_data(0x00)
        self.write_data(0x00)
        self.write_data(0x00)
        self.write_data(0x01)
        self.write_data(0x54)
        self.write_data(0x10)
        self.write_data(0x32)
        self.write_data(0x98)
        
        self.write_cmd(0x74)
        self.write_data(0x10)
        self.write_data(0x85)
        self.write_data(0x80)
        self.write_data(0x00)
        self.write_data(0x00)
        self.write_data(0x4E)
        self.write_data(0x00)
        
        self.write_cmd(0x98)
        self.write_data(0x3E)
        self.write_data(0x07)
        
        self.write_cmd(0x35)
        self.write_cmd(0x21)
        
        self.write_cmd(0x11)
        time.sleep(0.12)
        self.write_cmd(0x29)
        time.sleep(0.02)
    
    def color565(self, r, g, b):
        """Convert RGB values to 16-bit RGB565 format"""
        return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3)
    
    def _write_buffer_to_window(self, x, y, width, height, buffer_data):
        """Write a buffer to a specific window on the display"""
        self.set_window(x, y, x + width - 1, y + height - 1)
        
        self.cs.off()
        self.dc.on()
        self.spi.write(buffer_data)
        self.cs.on()
    
    def set_window(self, x0, y0, x1, y1):
        """Set the pixel address window for drawing"""
        # Column address set
        self.write_cmd(0x2A)
        self.write_data(x0 >> 8)
        self.write_data(x0 & 0xFF)
        self.write_data(x1 >> 8)
        self.write_data(x1 & 0xFF)
        
        # Row address set
        self.write_cmd(0x2B)
        self.write_data(y0 >> 8)
        self.write_data(y0 & 0xFF)
        self.write_data(y1 >> 8)
        self.write_data(y1 & 0xFF)
        
        # Memory write
        self.write_cmd(0x2C)
    
    def fill_screen(self, color):
        """Fill entire screen with a color (RGB565 format)"""
        self.set_window(0, 0, self.width - 1, self.height - 1)
        
        # Create a chunk of 1000 pixels
        chunk = bytearray(2000)  # 1000 pixels * 2 bytes per pixel
        for i in range(0, 2000, 2):
            chunk[i] = color >> 8      # High byte
            chunk[i + 1] = color & 0xFF # Low byte
        
        self.cs.off()
        self.dc.on()
        for i in range(58):  # 240*240 = 57600 pixels, so 58 chunks
            self.spi.write(chunk)
        self.cs.on()
    
    def fill_rect(self, x, y, width, height, color):
        """Fill a rectangle with a color"""
        if x >= self.width or y >= self.height:
            return
        
        # Clip to screen bounds
        if x + width > self.width:
            width = self.width - x
        if y + height > self.height:
            height = self.height - y
        
        pixels_to_send = width * height
        color_high = color >> 8
        color_low = color & 0xFF
        
        # Create buffer for the rectangle
        buffer = bytearray(pixels_to_send * 2)
        for i in range(0, len(buffer), 2):
            buffer[i] = color_high
            buffer[i + 1] = color_low
        
        # Send entire buffer at once
        self._write_buffer_to_window(x, y, width, height, buffer)

    def draw_text(self, x, y, text, color, bg_color=None, scale=1):
        """Draw text at position (x, y) by buffering entire lines"""
        char_width = round(8 * scale)
        char_height = round(8 * scale)
        
        lines = text.split('\n')
        current_y = y
        
        for line in lines:
            if current_y >= self.height:
                break
                
            if line.strip():  # Only process non-empty lines
                # Clip line to screen width
                if x >= self.width:
                    current_y += char_height
                    continue
                    
                visible_chars = min(len(line), (self.width - x) // char_width)
                if visible_chars <= 0:
                    current_y += char_height
                    continue
                
                actual_line_width = visible_chars * char_width
                
                # Clip height to screen bounds
                actual_line_height = min(char_height, self.height - current_y)
                if actual_line_height <= 0:
                    current_y += char_height
                    continue
                
                # Create buffer for entire line
                line_buffer = bytearray(actual_line_width * actual_line_height * 2)
                
                # Fill with background color if specified
                if bg_color is not None:
                    bg_high = bg_color >> 8
                    bg_low = bg_color & 0xFF
                    for i in range(0, len(line_buffer), 2):
                        line_buffer[i] = bg_high
                        line_buffer[i + 1] = bg_low
                
                # Draw each character into the line buffer
                for char_idx, char in enumerate(line[:visible_chars]):
                    char = char.upper()
                    if char not in self.font_8x8:
                        char = '?'
                    
                    font_data = self.font_8x8[char]
                    char_x_offset = char_idx * char_width
                    
                    # Draw character into line buffer with proper scaling
                    for row in range(8):
                        for col in range(8):
                            if font_data[row] & (1 << (7 - col)):
                                # Calculate the scaled pixel range for this font pixel
                                start_x = char_x_offset + round(col * scale)
                                end_x = char_x_offset + round((col + 1) * scale)
                                start_y = round(row * scale)
                                end_y = round((row + 1) * scale)
                                
                                # Fill the scaled pixel area
                                for pixel_y in range(start_y, min(end_y, actual_line_height)):
                                    for pixel_x in range(start_x, min(end_x, actual_line_width)):
                                        if pixel_x < actual_line_width and pixel_y < actual_line_height:
                                            buffer_index = (pixel_y * actual_line_width + pixel_x) * 2
                                            line_buffer[buffer_index] = color >> 8
                                            line_buffer[buffer_index + 1] = color & 0xFF
                
                # Send entire line at once
                self._write_buffer_to_window(x, current_y, actual_line_width, actual_line_height, line_buffer)
            
            current_y += char_height
    
    def draw_text_centered(self, y, text, color, bg_color=None, scale=1):
        """Draw text centered horizontally at the given y position"""
        char_width = round(8 * scale)
        text_width = len(text) * char_width
        x = (self.width - text_width) // 2
        self.draw_text(x, y, text, color, bg_color, scale)
    
    
    def draw_bitmap(self, x, y, bitmap_data, width, height, color, bg_color=None):
        """Draw a bitmap icon at position (x, y) using 10-line buffering"""
        if x >= self.width or y >= self.height:
            return
            
        clip_width = min(width, self.width - x) if x >= 0 else min(width + x, self.width)
        clip_height = min(height, self.height - y) if y >= 0 else min(height + y, self.height)
        
        if clip_width <= 0 or clip_height <= 0:
            return
        
        # Process bitmap in chunks of 100 lines max
        lines_per_chunk = min(100, clip_height)
        
        for chunk_start in range(0, clip_height, lines_per_chunk):
            chunk_height = min(lines_per_chunk, clip_height - chunk_start)
            
            if bg_color is not None:
                # With background: create buffer for chunk
                buffer = bytearray(clip_width * chunk_height * 2)
                
                for row_in_chunk in range(chunk_height):
                    bitmap_row = chunk_start + row_in_chunk
                    if bitmap_row >= height:
                        continue
                        
                    for col in range(clip_width):
                        if col >= width:
                            continue
                            
                        byte_index = (bitmap_row * width + col) // 8
                        bit_index = 7 - ((bitmap_row * width + col) % 8)
                        buffer_index = (row_in_chunk * clip_width + col) * 2
                        
                        if byte_index < len(bitmap_data) and bitmap_data[byte_index] & (1 << bit_index):
                            # Foreground pixel
                            buffer[buffer_index] = color >> 8
                            buffer[buffer_index + 1] = color & 0xFF
                        else:
                            # Background pixel
                            buffer[buffer_index] = bg_color >> 8
                            buffer[buffer_index + 1] = bg_color & 0xFF
                
                # Send chunk
                chunk_y = y + chunk_start
                if chunk_y < self.height:
                    self._write_buffer_to_window(x, chunk_y, clip_width, chunk_height, buffer)
            else:
                # Transparent background: collect foreground pixels into row segments
                for row_in_chunk in range(chunk_height):
                    bitmap_row = chunk_start + row_in_chunk
                    if bitmap_row >= height:
                        continue
                    
                    row_y = y + bitmap_row
                    if row_y >= self.height or row_y < 0:
                        continue
                    
                    # Find continuous segments of pixels in this row
                    col = 0
                    while col < width:
                        # Skip to next foreground pixel
                        while col < width:
                            pixel_x = x + col
                            if pixel_x >= self.width:
                                break
                            if pixel_x >= 0:
                                byte_index = (bitmap_row * width + col) // 8
                                bit_index = 7 - ((bitmap_row * width + col) % 8)
                                if byte_index < len(bitmap_data) and bitmap_data[byte_index] & (1 << bit_index):
                                    break
                            col += 1
                        
                        if col >= width:
                            break
                        
                        # Find end of continuous segment
                        segment_start = col
                        while col < width:
                            pixel_x = x + col
                            if pixel_x >= self.width:
                                break
                            byte_index = (bitmap_row * width + col) // 8
                            bit_index = 7 - ((bitmap_row * width + col) % 8)
                            if byte_index >= len(bitmap_data) or not (bitmap_data[byte_index] & (1 << bit_index)):
                                break
                            col += 1
                        
                        # Draw segment if valid
                        segment_length = col - segment_start
                        if segment_length > 0:
                            segment_x = x + segment_start
                            if segment_x >= 0 and segment_x < self.width:
                                # Create buffer for this segment
                                segment_buffer = bytearray(segment_length * 2)
                                for i in range(0, len(segment_buffer), 2):
                                    segment_buffer[i] = color >> 8
                                    segment_buffer[i + 1] = color & 0xFF
                                self._write_buffer_to_window(segment_x, row_y, segment_length, 1, segment_buffer)

    def draw_tea_registered(self):
        self.fill_screen(BLACK)
        x = (self.width - 64) // 2
        y = ((self.height - 64) // 2) - 20
        self.draw_bitmap(x, (y-10), TEA_BITMAP, width=64, height=64, color=TEA, bg_color=BLACK)
        self.draw_text_centered((y + 10 + 64), "TEA REGISTERED", DARK_TEA, scale=2)
        time.sleep(2)

    def draw_coffee_registered(self):
        self.fill_screen(BLACK)
        x = (self.width - 64) // 2
        y = ((self.height - 64) // 2) - 20
        self.draw_bitmap(x, (y - 10), COFFEE_BITMAP, width=64, height=64, color=COFFEE, bg_color=BLACK)
        
        self.draw_text_centered((y + 10 + 64), "COFFEE REGISTERED", DARK_COFFEE, scale=1)
        time.sleep(2)

    def draw_undo(self):
        self.fill_screen(BLACK)
        x = (self.width - 64) // 2
        y = ((self.height - 64) // 2) - 20
        self.draw_bitmap(x, (y - 10), UNDO_BITMAP, width=64, height=64, color=WHITE, bg_color=BLACK)
        
        self.draw_text_centered((y + 10 + 64), "UNDONE LAST DRINK", WHITE)
        time.sleep(2)

    def home_screen(self, username, teas, coffees):
        self.fill_screen(BLACK)
        line1 = f"{username}'s Drinks" if username[-1] not in "sS" else f"{username}' Drinks"
        line2 = f"Teas drunk: {teas}"
        line3 = f"Coffees drunk: {coffees}"

        self.draw_text_centered(90, line1, WHITE)
        self.draw_text_centered(120, line2, WHITE)
        self.draw_text_centered(150, line3, WHITE)
    
    def undo_failed(self):
        self.fill_screen(BLACK)
        self.draw_text_centered(120, "UNDO NOT POSSIBLE", WHITE)
        self.draw_text_centered(130, "TOO LONG SINCE LAST DRINK", WHITE)
        time.sleep(2)

    def welcome(self, username):
        self.fill_screen(BLACK)
        self.draw_text_centered(120, f"WELCOME {username}", WHITE)
        time.sleep(3)
        

        
# Example usage and test code
if __name__ == "__main__":
    # Initialize display
    spi = SPI(1, baudrate=10000000, sck=Pin(14), mosi=Pin(11))
    display = ManualGC9A01(
        spi=spi,
        dc=Pin(4, Pin.OUT),
        cs=Pin(13, Pin.OUT), 
        reset=Pin(6, Pin.OUT),
        backlight=Pin(0, Pin.OUT)
    )
    
    TEA = 0xC428
    DARK_TEA = 0x8AE5
    COFFEE = 0x9240
    DARK_COFFEE = 0x69A0
    
    # Clear screen
    display.fill_screen(BLACK)
    
    display.draw_tea_registered()
    display.draw_coffee_registered()
    display.draw_undo()
    display.undo_failed()
    display.home_screen("louis", 10, 10)